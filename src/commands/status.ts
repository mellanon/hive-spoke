import { Command } from "commander";
import { join } from "path";
import { withErrorHandling } from "../utils/errors";
import { loadYaml, writeYaml, yamlExists } from "../utils/yaml";
import { getGitState, isGitRepo } from "../utils/git";
import { ManifestSchema, type Manifest } from "../schemas/manifest";
import { LIFECYCLE_PHASES } from "../schemas/status";
import { success, warning, header } from "../utils/output";
import { version } from "../version";

interface StatusOptions {
  phase?: string;
  stdout?: boolean;
  json?: boolean;
}

async function runTestCommand(
  testCmd: string,
  cwd: string
): Promise<{ passing: number; failing: number }> {
  try {
    const proc = Bun.spawn(["sh", "-c", testCmd], {
      cwd,
      stdout: "pipe",
      stderr: "pipe",
    });

    const output = await new Response(proc.stdout).text();
    const stderr = await new Response(proc.stderr).text();
    const combined = output + stderr;

    // Parse common test output patterns
    // bun test: "42 pass" / "3 fail"
    const bunPass = combined.match(/(\d+)\s+pass/);
    const bunFail = combined.match(/(\d+)\s+fail/);

    // jest/vitest: "Tests: 5 passed, 2 failed"
    const jestPass = combined.match(/(\d+)\s+passed/);
    const jestFail = combined.match(/(\d+)\s+failed/);

    const passing =
      parseInt(bunPass?.[1] ?? jestPass?.[1] ?? "0", 10);
    const failing =
      parseInt(bunFail?.[1] ?? jestFail?.[1] ?? "0", 10);

    return { passing, failing };
  } catch {
    return { passing: 0, failing: 0 };
  }
}

export function registerStatusCommand(
  parent: Command,
  getJsonMode: () => boolean
): void {
  parent
    .command("status")
    .description("Generate status.yaml snapshot from current repo state")
    .option(
      "--phase <phase>",
      `Override lifecycle phase (${LIFECYCLE_PHASES.join(", ")})`
    )
    .option("--stdout", "Print to stdout instead of writing file", false)
    .action(
      withErrorHandling(async (opts: StatusOptions) => {
        const cwd = process.cwd();
        const collabDir = join(cwd, ".collab");
        const manifestPath = join(collabDir, "manifest.yaml");
        const statusPath = join(collabDir, "status.yaml");

        if (!(await isGitRepo(cwd))) {
          throw new Error("Not a git repository.");
        }

        if (!yamlExists(manifestPath)) {
          throw new Error(
            ".collab/manifest.yaml not found. Run 'hive-spoke init' first."
          );
        }

        header("Generating spoke status...");

        // Load and validate manifest
        const rawManifest = loadYaml(manifestPath);
        const manifest = ManifestSchema.parse(rawManifest);

        // Get current git state
        const gitState = await getGitState(cwd);
        success(`Git: ${gitState.branch}, dirty=${gitState.dirty}, behind=${gitState.behindRemote}`);

        // Determine phase
        let phase = opts.phase ?? "build";
        if (yamlExists(statusPath)) {
          const existing = loadYaml<{ phase?: string }>(statusPath);
          if (existing?.phase && !opts.phase) {
            phase = existing.phase;
          }
        }

        // Run tests if configured
        let tests = { passing: 0, failing: 0 };
        if (manifest.status?.test) {
          success(`Running tests: ${manifest.status.test}`);
          tests = await runTestCommand(manifest.status.test, cwd);
          success(`Tests: ${tests.passing} passing, ${tests.failing} failing`);
        } else {
          warning("No test command in manifest.yaml — skipping test count");
        }

        // Build status object
        const statusData = {
          schemaVersion: "1.0" as const,
          generatedAt: new Date().toISOString(),
          generatedBy: `hive-spoke ${version}`,
          phase,
          tests,
          git: {
            branch: gitState.branch,
            lastCommit: gitState.lastCommit,
            dirty: gitState.dirty,
            behindRemote: gitState.behindRemote,
          },
        };

        if (opts.stdout) {
          const yaml = await import("js-yaml");
          console.log(yaml.dump(statusData, { indent: 2 }));
        } else {
          writeYaml(
            statusPath,
            statusData,
            "# Spoke status snapshot — auto-generated by hive-spoke\n# Regenerate with: hive-spoke status"
          );
          success(`Written to .collab/status.yaml`);
        }

        console.log(
          `\nStatus snapshot generated (${phase}, ${tests.passing} tests passing).`
        );
      }, getJsonMode)
    );
}
