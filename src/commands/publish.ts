import { Command } from "commander";
import { join, basename } from "path";
import { existsSync, readFileSync, mkdirSync, writeFileSync, cpSync } from "fs";
import { $ } from "bun";
import { withErrorHandling } from "../utils/errors";
import { loadYaml, yamlExists } from "../utils/yaml";
import { isGitRepo } from "../utils/git";
import { ManifestSchema, type Manifest } from "../schemas/manifest";
import { success, warning, fail, header, result } from "../utils/output";
import { version } from "../version";

interface PublishOptions {
  dryRun?: boolean;
  branch?: string;
  json?: boolean;
}

async function runCommand(
  cmd: string,
  cwd: string
): Promise<{ stdout: string; exitCode: number }> {
  try {
    const proc = Bun.spawn(["sh", "-c", cmd], {
      cwd,
      stdout: "pipe",
      stderr: "pipe",
    });
    const stdout = await new Response(proc.stdout).text();
    await proc.exited;
    return { stdout: stdout.trim(), exitCode: proc.exitCode ?? 1 };
  } catch {
    return { stdout: "", exitCode: 1 };
  }
}

export function registerPublishCommand(
  parent: Command,
  getJsonMode: () => boolean
): void {
  parent
    .command("publish")
    .description("Project spoke status to the hub via PR")
    .option("--dry-run", "Show what would be published without creating PR", false)
    .option("--branch <name>", "Override the PR branch name")
    .action(
      withErrorHandling(async (opts: PublishOptions) => {
        const cwd = process.cwd();
        const collabDir = join(cwd, ".collab");
        const manifestPath = join(collabDir, "manifest.yaml");

        // Validate prerequisites
        if (!(await isGitRepo(cwd))) {
          throw new Error("Not a git repository.");
        }

        if (!yamlExists(manifestPath)) {
          throw new Error(
            ".collab/manifest.yaml not found. Run 'hive-spoke init' first."
          );
        }

        header("Publishing spoke to hub...");

        // 1. Load manifest to get hub target
        const rawManifest = loadYaml(manifestPath);
        const manifest = ManifestSchema.parse(rawManifest);
        success(`Hub target: ${manifest.hub}`);
        success(`Project: ${manifest.project}`);

        // 2. Refresh status
        console.log("\n--- Refreshing status ---");
        const statusResult = await runCommand(
          `bun ${join(import.meta.dir, "..", "index.ts")} status`,
          cwd
        );
        if (statusResult.exitCode !== 0) {
          throw new Error("Status generation failed. Fix issues before publishing.");
        }

        // 3. Validate
        console.log("\n--- Validating compliance ---");
        const validateResult = await runCommand(
          `bun ${join(import.meta.dir, "..", "index.ts")} validate`,
          cwd
        );
        if (validateResult.exitCode !== 0) {
          throw new Error(
            "Validation failed. Fix errors before publishing."
          );
        }
        success("Compliance check passed");

        // 4. Determine branch and PR details
        const spokeName = manifest.project;
        const branchName =
          opts.branch ?? `spoke/${spokeName}/status-update`;
        const prTitle = `spoke: ${spokeName} status update`;

        // Read .collab/ files for the PR body
        const statusYaml = readFileSync(
          join(collabDir, "status.yaml"),
          "utf-8"
        );
        const statusData = loadYaml<Record<string, unknown>>(
          join(collabDir, "status.yaml")
        );

        const prBody = [
          `## Spoke Status Update: ${spokeName}`,
          "",
          `**Operator:** ${manifest.maintainer}`,
          `**Phase:** ${(statusData as any)?.phase ?? "unknown"}`,
          `**Hub:** ${manifest.hub}`,
          `**Generated by:** hive-spoke ${version}`,
          "",
          "### Status Snapshot",
          "```yaml",
          statusYaml.trim(),
          "```",
          "",
          "### Security Reflexes",
          `- Signing: ${manifest.security?.reflexes?.signing ? "active" : "inactive"}`,
          `- Secret scanning: ${manifest.security?.reflexes?.secretScanning ? "active" : "inactive"}`,
          `- Sandbox enforcer: ${manifest.security?.reflexes?.sandboxEnforcer ? "active" : "inactive"}`,
          `- Content filter: ${manifest.security?.reflexes?.contentFilter ? "active" : "inactive"}`,
          "",
          "---",
          `Projected by [hive-spoke](https://github.com/mellanon/hive-spoke) ${version}`,
        ].join("\n");

        if (opts.dryRun) {
          console.log("\n--- DRY RUN ---");
          console.log(`Branch: ${branchName}`);
          console.log(`PR Title: ${prTitle}`);
          console.log(`\nPR Body:\n${prBody}`);
          console.log("\nFiles that would be updated in hub:");
          console.log(`  projects/${spokeName}/.collab/manifest.yaml`);
          console.log(`  projects/${spokeName}/.collab/status.yaml`);
          console.log(`  projects/${spokeName}/.collab/operator.yaml`);
          result(true, "Dry run complete — no changes made");
          return;
        }

        // 5. Clone hub, create branch, copy files, create PR
        const hubRepo = manifest.hub;
        const tmpDir = join(
          process.env.TMPDIR ?? "/tmp",
          `hive-spoke-publish-${Date.now()}`
        );

        try {
          // Clone the hub repo
          console.log(`\nCloning hub: ${hubRepo}...`);
          const cloneResult = await runCommand(
            `gh repo clone ${hubRepo} ${tmpDir} -- --depth 1`,
            cwd
          );
          if (cloneResult.exitCode !== 0) {
            throw new Error(
              `Failed to clone hub repo: ${hubRepo}. Is 'gh' authenticated?`
            );
          }
          success(`Cloned ${hubRepo}`);

          // Create or checkout branch
          const branchCheck = await runCommand(
            `git ls-remote --heads origin ${branchName}`,
            tmpDir
          );
          if (branchCheck.stdout.includes(branchName)) {
            // Branch exists — checkout and update
            await runCommand(`git checkout ${branchName}`, tmpDir);
            success(`Checked out existing branch: ${branchName}`);
          } else {
            await runCommand(
              `git checkout -b ${branchName}`,
              tmpDir
            );
            success(`Created branch: ${branchName}`);
          }

          // Copy .collab/ files into hub's project directory
          const hubProjectDir = join(
            tmpDir,
            "projects",
            spokeName,
            ".collab"
          );
          mkdirSync(hubProjectDir, { recursive: true });

          for (const file of [
            "manifest.yaml",
            "status.yaml",
            "operator.yaml",
          ]) {
            const src = join(collabDir, file);
            const dst = join(hubProjectDir, file);
            if (existsSync(src)) {
              cpSync(src, dst);
              success(`Copied ${file}`);
            }
          }

          // Stage files first, then check for actual changes
          await runCommand(
            `git add projects/${spokeName}/.collab/`,
            tmpDir
          );

          const diffCheck = await runCommand(
            "git diff --cached --quiet",
            tmpDir
          );
          if (diffCheck.exitCode === 0) {
            console.log("\nNo changes to publish — hub is already up to date.");
            result(true, "Hub is current, no PR needed");
            return;
          }
          const commitMsg = `spoke: ${spokeName} status update\n\nProjected by hive-spoke ${version}\nPhase: ${(statusData as any)?.phase ?? "unknown"}\n\nOrigin: agent\nAttested-By: ${manifest.maintainer}`;
          await runCommand(
            `git commit -m "${commitMsg}"`,
            tmpDir
          );
          success("Committed changes");

          // Push
          const pushResult = await runCommand(
            `git push -u origin ${branchName}`,
            tmpDir
          );
          if (pushResult.exitCode !== 0) {
            throw new Error("Failed to push branch to hub.");
          }
          success(`Pushed to origin/${branchName}`);

          // Check if PR already exists
          const existingPR = await runCommand(
            `gh pr list --repo ${hubRepo} --head ${branchName} --json number --jq '.[0].number'`,
            tmpDir
          );

          if (existingPR.stdout && existingPR.stdout !== "null") {
            // PR exists — it's been updated by the push
            success(`Updated existing PR #${existingPR.stdout}`);
            result(
              true,
              `Spoke published — PR #${existingPR.stdout} updated`
            );
          } else {
            // Create new PR
            const prResult = await runCommand(
              `gh pr create --repo ${hubRepo} --title "${prTitle}" --body "${prBody.replace(/"/g, '\\"')}" --head ${branchName}`,
              tmpDir
            );

            if (prResult.exitCode !== 0) {
              throw new Error("Failed to create PR on hub.");
            }
            success(`PR created: ${prResult.stdout}`);
            result(true, `Spoke published to ${hubRepo}`);
          }
        } finally {
          // Cleanup
          await runCommand(`rm -rf ${tmpDir}`, cwd);
        }
      }, getJsonMode)
    );
}
